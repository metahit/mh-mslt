---
title: "Preparing data from the Global Burden of Disease for multi-state data frame"
author: -"Belen, Zapata-Diomedi  <belen.zapata-diomedi@rmit.edu.au>"
        - "Alan, Both"
        -"Ali Abbas"
date:   "`r Sys.time()`"
output:
    html_document:
        code_folding: show
params:
    date:   !r Sys.Date() - 1
always_allow_html: yes
---


# Introduction
Generate inputs for the proportional multi-state life table for: United Kingdom, England, Wales, Northen Ireland, Scotland, Wales, English regions (East Midlands, East of England, Greater London, North East England, North West England, South East England, South West England, West Midlands, Yorkshire and the Humber) and the English City Regions (Liverpool, Nottingham, Bristol, Northeast, Greater Manchester, Sheffield, West Midlands, Leeds and London). 
Raw inputs are in "inputs" folder. Processed data is in "output" folder. Final data save in mh-execute inputs/mslt.
*GBD will update data end of October*


```{r Libraries, echo = FALSE, message = FALSE, warning = FALSE}
library(knitr)
library(kableExtra)
library(plyr)
library(lubridate)
library(ggplot2)
library(ggjoy)
library(ggpubr)
library(plm)
library(PerformanceAnalytics)
library(pander)
library(dplyr)
library(tidyr)
library(tibble) 
library(knitr)
library(readxl)
library(stringr)
library(Hmisc)
library(DiagrammeR)
library(tinytex)
library(tibble)
options(scipen = 999)
```

```{r,eval=FALSE}
rm (list = ls()) 
options(scipen=999)
mypath <- 'C:/Metahit/'
relative_path_execute <- paste0(mypath,'mh-execute')
relative_path_gbd <- paste0(mypath,'mh-mslt/input/gbd/GBD2017/METAHIT/')
relative_path_mslt <- paste0(mypath,'mh-mslt/')

```

Read look-up table mapping between local authorities and city regions, and add names for regions that are not city regions. For the city regions we add up data available for lower and upper tier local authorithy areas. 

```{r,eval=FALSE}
names_non_cr <- c("United Kingdom", "England", "East Midlands", "East of England", "Greater London", "North East England", 
                  'North West England', "South East England", "South West England", "West Midlands", "Yorkshire and the Humber", 
                  "Northern Ireland", "Scotland", "Wales")
local_government_areas <- read_csv(file.path(relative_path_execute, "inputs/mh_regions_lad_lookup.csv"))
for (i in names_non_cr){
  local_government_areas <- rbind(local_government_areas, rep(i, ncol(local_government_areas)))
}
local_government_areas  <- local_government_areas %>%
    dplyr::filter(!is.na(cityregion)) %>%
    dplyr::rename(location = lad11nm) %>%
    dplyr::mutate(location = gsub('St. Helens', 'St Helens', location))
```

Read original GBD data for 2017. UPDATE with new release Oct 2020.
```{r,eval=FALSE}
gbd1 <- read_csv(file.path(relative_path_gbd, "IHME-GBD_2017_DATA-3e0b192d-1.csv"))
gbd2 <- read_csv(file.path(relative_path_gbd, "IHME-GBD_2017_DATA-3e0b192d-2.csv"))
gbd3 <- read_csv(file.path(relative_path_gbd, "IHME-GBD_2017_DATA-3e0b192d-3.csv"))
gbd4 <- read_csv(file.path(relative_path_gbd, "IHME-GBD_2017_DATA-3e0b192d-4.csv"))
gbd5 <- read_csv(file.path(relative_path_gbd, "IHME-GBD_2017_DATA-3e0b192d-5.csv"))
gbd <- rbind(gbd1, gbd2, gbd3, gbd4, gbd5) %>%
    dplyr::filter(location_name %in% local_government_areas$location)
rm(gbd1, gbd2, gbd3, gbd4, gbd5)

```

Read look-up table mapping between local authorities and city regions, and add names for regions that are not city regions

```{r,eval=FALSE}
names_non_cr <- c("United Kingdom", "England", "East Midlands", "East of England", "Greater London", "North East England", 
                  'North West England', "South East England", "South West England", "West Midlands", "Yorkshire and the Humber", 
                  "Northern Ireland", "Scotland", "Wales")
local_government_areas <- read_csv(file.path(relative_path_execute, "inputs/mh_regions_lad_lookup.csv"))
for (i in names_non_cr){
  local_government_areas <- rbind(local_government_areas, rep(i, ncol(local_government_areas)))
}


local_government_areas  <- local_government_areas %>%
    dplyr::filter(!is.na(cityregion)) %>%
    dplyr::rename(location = lad11nm) %>%
    dplyr::mutate(location = gsub('St. Helens', 'St Helens', location))



  ## Join geographical data to GBD data original look up table. First check similarities between locations in gbd data and local_goverment_areas data.
  
  ### Compare gdd location_name with local_goverment_areas locations (local authority districs (lad))

  gbd_loc <- unique(gbd$location_name)
  ons_lad <- unique(local_government_areas$location)
  diff <- setdiff(ons_lad, gbd_loc) ### difference ony
  
  ### GBD data for nottingham city regions is not available local authority district (Ashfield, Bassetlaw, Broxtow, Gedling, Mansfield, Newark and        Sherwood,Rushcliffe) but for Nottingham and Nottinghamshire. Then we used Notthinghan and Nottinghamshire gbd data for Nottinham city region
  ### Replace as per above. City of London still missing from GBD data.

  local_government_areas <- local_government_areas %>% mutate(location=ifelse(cityregion=="nottingham" & location!="Nottingham", "Nottinghamshire", location))
  
  ## check difference 
  
  gbd_loc <- unique(gbd$location_name)
  ons_lad <- unique(local_government_areas$location)
  diff <- setdiff(ons_lad, gbd_loc)
 
  
  ## Join local goverment data to get city regions names and then aggregate data (numbers) by city region.
  
  gbd <- gbd %>% left_join(local_government_areas, by=c("location_name"="location"))

  
  

```


Read disease coding table

```{r,eval=FALSE}
disease_names_execute <- read_csv(file.path(relative_path_execute, "inputs/dose_response/disease_outcomes_lookup.csv")) %>%
    select(GBD_name, acronym) %>%
    mutate(disease = tolower(GBD_name))
    
DISEASE_SHORT_NAMES <- data.frame(disease = tolower(as.character(unique(gbd$cause_name))), 
                                  sname = tolower(abbreviate(unique(gbd$cause_name, max = 2))),
                                  stringsAsFactors = F) %>%
    dplyr::mutate(is_not_dis = ifelse((str_detect(disease, "injuries") |
                                str_detect(disease, "All causes") |
                                str_detect(disease, "Lower respiratory infections")), 
                               1, 0) ) %>%
    dplyr::mutate(is_not_dis = case_when(sname == "allc"  ~  2,
                                  sname == "lwri"  ~  1,
                                  ## Code for major depressive disorder (no deaths) and hypertensive heart disease (no incidence)
                                  sname == "hyhd"  ~  3,
                                  sname == "mjdd"  ~  3,
                                  TRUE  ~  is_not_dis)) %>%
    left_join(disease_names_execute, by="disease") %>%
    dplyr::mutate(acronym = ifelse(str_detect(disease, "injuries"), disease, acronym),
           acronym = word(acronym, 1),
           males = ifelse(disease %in% c("uterine cancer", "breast cancer"), 0, 1),
           females = ifelse(disease %in% "prostate cancer", 0, 1),
           sname = gsub("'", '', sname),
           acronym = ifelse(is.na(acronym), "no_pif", acronym))

saveRDS(DISEASE_SHORT_NAMES, paste0(relative_path_mslt, "output/parameters/DISEASE_SHORT_NAMES.rds"))
```    

# Inputs Proportional multi-state life table

## Data inputs

Data inputs for the proportional multi-state life table model (PMSLT) include inputs for: general life table (population, mortality rates and prevalent years lived with disability rates for all causes (YLD)), diseases life tables (incidence and case fatality) and injuries process (mortality rates and years lived with disability rates). Table 1 describes all data inputs for the MSLT. Each of the MSLT components and related code are explained below Table 1. Data inputs were generated for: United Kingdon, England, Wales, Scotland, England Regions () and English city regions/Combined Authorities (). We used Global Burden of Disease data [@RN1] for all data inputs, and an Disbayes to derive case fatality (not available in GBD). GBD data is available for rates per 100,000 people, total numbers and percentage by age groups (5-years smallest category) and sex. Percentage represents proportion of the contribution of a diseases to the total burden, we do not use percentages. 

```{r, echo=FALSE, include=TRUE}

pmslt_inputs <- tribble(
~Component, ~"Data needs", ~"Input data", ~"Data processing",
"General life table", "Population numbers and mortality rates", "Population and all-cause mortality by age-group (5 years) and sex", "Population numbers by 5-year age groups and sex were derived from GBD data for rates (per 100,000) and numbers data (i.e. number*100,000/rate). For the English city regions data is avaialbe for Lower Tier Local Authority (LTLA) and Upper Tier Local Authority (UTLA). Population numbers for LTLA and UTLA were aggregated to City Regions. For UK, Scotland, Wales and England Regions no futher steps were required. Mortality rates per one were derived by diving all-cause mortality rates by population numbers by age and sex. Interpolation was used to derived single-year mortality rates from 5-year data.", 
"General life table", "All-cause YLDs", "All-cause pYLDs by 5-year age groups and sex", "Rates per one derived from numbers and population data and interpolated to one-year age groups. Same aggreagation process as for mortlaity was used for City Regions.", 
"Disease life table", "Diseases: Disability weights, incidence and case fatality", "Disease specific pYLDs and prevalence. Incidence and case fatality were derived using Disbayes", "Section XX outlines Disbayes process. Disability weights were calculated by dividing disease specific pYLDs by prevalence and adjusted by all cause pYLDs for 5-year age groups and sex and then interpolated to 1-year age groups.",
 "Injuries: pYLDs and mortality rates", "PYLDs and mortality rates for road injures for pedestrians, cyclist, COMPLETE", "pYLD and mortality numbers by 5-year age group and sex", "Rates per one derived from numbers and population data and interpolated to 1-year age groups",
"Diseases trends", "TO DO","TO DO", "Explained in sections Trends"
)
kable(pmslt_inputs, booktabs = T, caption = " Table 1: PMSLT inputs", longtable = TRUE) %>%

  column_spec(1:2, width = "7em") %>%
  column_spec(3:4, width = "15em") %>%
  row_spec(0, bold = T)  %>%
  kable_styling()
```

## Data processing
Steps and code to generate inputs to run PMSLT.

## Calculate baseline data by area
Orginal GBD data tidy up for later processing for PMSLT dataframe and disbayes inputs. Generates dataframe for all areas (city regions, UK, countries and English Regions). Inputs are by age (5-year groups) and sex.
```{r,eval=FALSE}
source(paste0(relative_path_mslt, "R/prepare_GBD.R"))

gbd_wider <- calculateGBDwider(gbd = gbd, local_government_areas = local_government_areas)
# saveRDS(gbd_wider, paste0(relative_path_mslt, "data/gbd_wider.rds")) ## save here to compae with Mel data generation
```
## Calculate baseline data for PMSLT
A PMSLT dataframe of inputs is generated from above dataframe by single year of age and adding Disbayes outputs. Disbayes output generated by Chris J. Data saved in input folder of mh-execute.
```{r,eval=FALSE}
source(paste0(relative_path_mslt, "R/prepare_GBD.R"))

### Please check commnent manual entry for function calculateMSLT
### Load disbayes data
load("C:/Metahit/mh-mslt/input/city regions/Output disbayes/cityregions_smoothed_res.rda")

mslt_inputs <- list()
index <- 1
for (loc in unique(local_government_areas$cityregion)) {

mslt_inputs[[index]] <- calculateMSLT(gbd_wider, location = loc , disease)

names(mslt_inputs)[index] <- paste0(loc)

write.csv(mslt_inputs[[index]], file=paste0(relative_path_execute, "/inputs/mslt/", loc, "_mslt",".csv"))


index <- index + 1

}
```
